Formation wild

/////////////////////////
1er exercice
///////////////////////////

$ mkdir node-typescript-101
$ cd node-typescript-101
$ npm init -y
$ npm i -D ts-node-dev
$ echo 'console.log("welcome home ðŸ ");' > index.ts
$ npx ts-node-dev --respawn index.ts 

Ceci permet dâ€™initier et lancer un projet basique en Node avec Typescript
Ouvrir un fichier texte et afficher son contenu :
https://grafikart.fr/tutoriels/nodejs-filesystem-2083


///////////////////////////////
2Ã¨me exercice
//////////////////////////////

// crÃ©ation du dossier "projet"
$ mkdir the-good-corner
$ cd the-good-corner

// initialisation du rÃ©pertoire git
$ git init

// crÃ©ation du backend
$ mkdir backend
$ cd backend
$ touch .gitignore
$ echo â€œnode_modulesâ€ >> .gitignore

$ npm init
//Ou, pour skipper les question et valider les rÃ©ponses par dÃ©fault
$ npm init -y
//installation du modules typescript dans l'environnement de dÃ©veloppement
// + installation de express
$ npm install ts-node-dev express
$ mkdir src
$ cd src
$ touch index.ts
$ cd ..
$ code .

//////////////////////
Le fichier package.json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "ts-node-dev --respawn ./src/index.ts"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2",
    "ts-node-dev": "^2.0.0"
  }
}

//////////////////////
le fichier index.ts
console.log("hello from typescript");

On verifie que tout fonctionne :
npm start

/////////////////
Pour rappel !!
ts-node-dev -dependencies
tsx --init
tsx-node-dev

/////////////////////////////
Installation de express
// si ce n'est pas dÃ©jÃ  fait !!
$ npm install express

modifier index.ts

import express from "express";

const app = express();
const port = process.env.PORT || 3000;

app.get("/", (req, res) => {
  res.send("Hello World!");
});

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`);
});

// Ã  faire Ã©galement
npm install --save @types/express

/////////////////////////////////////
Using REST Client to query the API
/////////////////////////////////////

Create http folder
Create hello_world.http file
Write and send request

////////////////////////////
Le routing
///////////////////////////

// dans le fichier index.ts
import router from "./routes";
app.use("/", router);

//////////////////
// crÃ©ation des routes
mkdir routes
cd routes
touch index.ts

///////////////////////////////
// dans le fichier routes/index.ts
import express from "express";
import adsRoutes from "./ads.routes";

const router = express.Router();

router.use('/ads', adsRoutes);

router.get('/', (req, res) => {
    console.log('Mon index');
    res.send('Hello');
})

export default router;

////////////////////
touch ads.routes.ts

import express from "express";
import { getAds }  from "../controllers/ads.controller";

const router = express.Router();

router.get("/", getAds);

export default router;

////////////////////
// crÃ©ation des controllers
normalement, on est dans le rÃ©pertoire /routes
mkdir ../controllers
cd ../controllers
touch ads.controller.ts

import { Request, Response } from "express";

// Afficher toutes les annonces
const getAds = async (req: Request, res: Response) => {
      const ads = "Hello ad";
      res.send(ads);
}

export { getAds };

////////////////////

app.get("/ads", (req, res) => {
  res.send(ads);
});

app.post("/ads", (req, res) => {
  console.log(req.body);
  res.send("Request received, check the backend terminal");
});

app.delete("/ad", (req, res) => {
  ads = ads.filter((ad) => ad.id !== req.body.id);
  res.send("The ad was deleted");
});

app.put("/ad", (req, res) => {
  ads = ads.map((ad) => {
    if (ad.id !== req.body.id) {
      return ad;
    } else {
      return req.body.newAd;
    }
  });
  res.send("The ad was updated");
});



///////////////////////////
Indispensable pour lire les donnÃ©es json
dans src/index.ts
app.use(express.json());


//////////////////////////////
Le sql avec sqlite
//////////////////////////////

Dans vs code installer l'extension sqlite de alexcvzz
Ouvrir la BDD avec CMD + SHIFT + P : SQLite: Open Database

// installer sqlite3
(ici, dans notre exemple, nous sommes dans le repertoire backend)
npm install sqlite3

/////////////////
// fichier de la base de donnÃ©es
mkdir src/db

// fichier de la base de donnÃ©es
touch myproject.sqlite

// fichier d'initialisation de la structure de la BDD
touch queries.sql

Drop table if EXISTS categorie;

CREATE TABLE categories (
  id integer PRIMARY KEY,
  name varchar(255) not null
);

INSERT INTO categories (name) VALUES
('vÃªtement'),
('voiture'),
('autre');

//////////////
si l'on souhaite travailler avec typeORM, passer au chapitre correspondant
/////////////

// crÃ©er le ficher de connection
dans /db   touch sqliteConfig.ts

import sqlite3 from "sqlite3";
import path from "path";

const dbPath = path.resolve(__dirname, "good_corner.sqlite");

const db = new sqlite3.Database(dbPath, (err) => {
    if (err) {
        return console.error(err.message);
    }
    console.log('Connected to the SQLite database.');
});

export default db;


// consolider la mise en oeuvre avec un import du fichier prÃ©cÃ©dent !!!!
Dans index.ts
â€¦
import sqlite3 from 'sqlite3';
const db = new sqlite3.Database('db.sqlite');
â€¦

exemple de route
app.get("/ad", (req, res) => {
  db.all("SELECT * FROM ad", (err, rows) => {
    res.send(rows);
  })
});

////////////////////
les requÃªtes prÃ©parÃ©es

const stmt = db.prepare(
    "insert into ad (title, description, owner) Values (?, ?, ?)"
);
stmt.run([
    req.body.title,
    req.body.description,
    req.body.owner
])

//////////////////////////
les differentes instructions

db.run(sql [, param, ...] [, callback])
ExÃ©cute une seule requÃªte SQL qui ne retourne pas de donnÃ©es.
UtilisÃ©e principalement pour INSERT, UPDATE, DELETE

db.exec(sql [, callback])
ExÃ©cute plusieurs requÃªtes SQL.
UtilisÃ©e pour les transactions.

db.all(sql [,param, ...] [, callback])
ExÃ©cute la requÃªte et renvoie toutes les lignes dans la callback.

db.get(sql [,param, ...] [, callback])
Idem que db.all mais ne retourne que la 1Ã¨re ligne dans la callback.

/////////////////
La mÃ©thode merise
///////////////////

- ModÃ¨le Conceptuel de donnÃ©es (MCD)
  ReprÃ©sentation claire des donnÃ©es. DÃ©finition des dÃ©pendances fonctionnelles.

- ModÃ¨le Logique de donnÃ©es (MLD)
  Ajout des clÃ©s primaires et Ã©trangÃ¨res

- ModÃ¨le Physique de donnÃ©es (MPD)
  Prise en compte des spÃ©cificitÃ©s du SGBD utilisÃ©

////////////
Les relations :
one to one
one to many
many to many

////////////////////
clÃ© Ã©trangÃ¨re en sql
school_id INT,
FOREIGN KEY (school_id) REFERENCES school(id)

////////////////
Les jointures

////////////////
Les index

//////////////
Les transactions

//////////////////////////
POO
/////////////////////////

///////////////////////
TypeORM
///////////////////////

////////////
Les entities

// installer typeorm
$ npm install typeorm
$ npm install reflect-metadata

// installer ???

// modifier le fichier tsconfig.json
{
  â€¦,
  "emitDecoratorMetadata": true,
  "experimentalDecorators": true,
  â€¦
}

////////////////////////////
// DÃ©finir les informations de connexion Ã  la base de donnÃ©es
// fichier src/config/db.ts

// pour sqlite
import { DataSource } from "typeorm";
import { Student } from â€œ./entities/student;
import { School } from â€œ./entities/school;
import { Language } from â€œ./entities/language; 

export const dataSource = new DataSource({
  type: "sqlite",
  database: "../../wild.sqlite",
  entities: [Student, School, Language],
  synchronize: true,
});

// pour renseigner toutes les entitÃ©s en mÃªme temps
entities: [â€œsrc/entities/*.tsâ€],

// pour postgres
import { DataSource } from "typeorm";

export const dataSource = new DataSource({
    type: "postgres",
    host: "localhost",
    port: 5432,
    username: "test",
    password: "test",
    database: "test",
    synchronize: true,
    logging: true,
    entities: [Post, Category],
});

/////////////////////////////////////
// initialiser la datasource en mÃªme temps que le serveur
import "reflect-metadata";
import express from 'express';

â€¦

app.listen(5001, async () => {
  await dataSource.initialize();
  console.log('Server launch on http://localhost:5001');
});

/////////////////////////
// dÃ©finir une entitÃ©

DÃ©finition dâ€™une entitÃ© avec le dÃ©corateur @Entity
DÃ©finition dâ€™une colonne avec le dÃ©corateur @Column({options})

Un active record est un pattern de programmation qui dÃ©fini que :
Chaque enregistrement de la base est reprÃ©sentÃ© par un objet qui contient les donnÃ©es elles-mÃªmes mais aussi tous les comportements (mÃ©thodes) liÃ© Ã  ces donnÃ©es (select, insert, update, remove).
Ceci est possible grÃ¢ce Ã  lâ€™hÃ©ritage de la classe BaseEntity.

// src/entities/student.ts

import { 
  BaseEntity, 
  Column, Entity, 
  PrimaryGeneratedColumn 
} from "typeorm";

@Entity()
export class Student extends BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  firstname: string;

  @Column()
  name: string;

  @Column()
  birthday: Date;

  @Column()
  address: string;
}

///////////////////////
// CrÃ©ation d'une instance
La mÃ©thode save() hÃ©rite de la class BaseEntity

// sur le fichier src/index.ts (plutÃ´t dans le systÃ¨me de route, Ã  corriger)

app.post("/student", (req, res) => {
  const ad = new Student();
  ad.firstname = req.body.firstname;
  ad.name = req.body.name;
  ad.birthday = req.body.birthday;
  ad.address = req.body.address;

  ad.save();

  res.send(ad);
});

app.put("/ad/:id", async (req, res) => {
  const id = parseInt(req.params.id);
  const st = await Student.findOneBy({ id })
  if (st !== null) {
    st.firstname = req.body.firstname;
    st.name = req.body.name;
    st.birthday = req.body.birthday;
    st.address = req.body.address;
    st.save();
  }
  res.send(st);
});

app.delete("/ad/:id", async (req, res) => {
  const id = parseInt(req.params.id);
  await Student.delete({ id });
  res.send('OK');
});

// ou
app.delete("/ad/:id", async (req, res) => {
  const id = parseInt(req.params.id);
  const st = Student.findOneBy({ id });
  if (st !== null) {
    st.remove();
  }
  res.send('OK');
});

/////////////////
La validation : class-validator

import { 
  BaseEntity, 
  Column, Entity, 
  PrimaryGeneratedColumn } from "typeorm";
import { Length, Min, Max } from "class-validator";

@Entity()
export class School extends BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  @Length(10, 100, {
    message: "Entre 10 et 100 caractÃ¨res"
  })
  city: string;

  @Column()
  @Min(10)
  @Max(80)
  capacity: number;
}

////////////////////
import { validate } from â€œclass-validatorâ€;

const student = new Student();
student.firstname = â€œMarcâ€;
student.name = â€œDupontâ€;

const errors = await validate(post)
if (errors.length > 0) {
    throw new Error(`Validation failed!`)
} else {
    await dataSource.manager.save(post)
}


///////////////////
// recuperation des enregistrement

// plusieurs
import { LessThan, Like } from "typeorm"

const students = await Student.find();

const students = await Student.findBy({
	name: â€œRobâ€
});

const schools = await School.findBy({
	capacity: LessThan(40)
});

const schools = await School.findBy({
	city: Like(â€œ%ar%â€)
});

//un seul
app.get("/ad", async (req, res) => {
  const ads = await Student.find();
  res.send(ads);
});

app.get("/ad/:id", async (req, res) => {
  const id = parseInt(req.params.id);
  const ad = await Ad.findOneBy({ id });
  res.send(ad);
});

///////////////////
//les transactions

//une transaction est une fonction avec un callback
await dataSource.transaction(async (transactionalEntityManager) => {
  // Vos requÃªtes
});


// OU

const queryRunner = dataSource.createQueryRunner();
await queryRunner.connect();
await queryRunner.startTransaction();
// Vos requÃªtes
await queryRunner.commitTransaction();
await queryRunner.rollbackTransaction();
await queryRunner.release();

////////////
// Le dÃ©corateur @Index()

// Entity listener
PossibilitÃ© dâ€™exÃ©cuter des mÃ©thodes de la classe dâ€™entitÃ© suivant certains Ã©vÃ¨nements.
Assignation de la date de crÃ©ation juste avant lâ€™insertion.
import { â€¦, BeforeInsert } from "typeorm";
import { Category } from "./category";

@Entity()
export class Ad extends BaseEntity {
  â€¦
  @Column()
  location: string;
  
  @ManyToOne(() => Category)
  category: number;

  @Column()
  createdAt: Date;

  @BeforeInsert()
  updateDates() {
      this.createdAt = new Date();
  }
}


////////////
// Les types de relations
TypeORM gÃ¨re tous les types de relations avec des dÃ©corateurs :
@ManyToOne() : Un Ã©lÃ¨ve Ã  une Ã©cole.
@OneToMany() : Une Ã©cole Ã  plusieurs Ã©lÃ¨ves.
@ManyToMany() : Une Ã©cole enseigne plusieurs langages.
@OneToOne() : Un Ã©lÃ¨ve a un profil.

â€¦

  @ManyToOne(() => School, school => school.students)
  school: School;


  @OneToMany(() => Student, student => student.school)
  students: Student[];


  @ManyToMany(() => Language)
  @JoinTable()
  languages: Language[];


  @ManyToMany(() => School, school => school.languages)
  schools: School[];

// requÃªtage
const schools = await School.find({
    relations: {
      students: true,
      languages: true
    }
  });
  
  // requÃªte complexe
  import { MoreThan } from "typeorm";

await School.find({
    select: {
      id: true,
      city: true,
      address: true
    },
    relations: {
      students: true,
      languages: true
    },
    where: [{ capacity: MoreThan(30) }],
    order: {
      capacity: 'DESC'
    },
    skip: 10,
    take: 5
  });





